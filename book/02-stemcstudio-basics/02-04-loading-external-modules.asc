=== Using NPM Packages (a.k.a. External Modules or Libraries)

The ability to consume external modules in the form of NPM packages is one of the more powerful features of STEMCstudio.
An external library is JavaScript code that exists outside of your STEMCstudio project and yet can be loaded and called from your STEMCstudio project. External libraries often provide large coarse-grained functionality such as diagramming or plotting. External libraries are an effective way to reuse functionality, dramatically improving your productivity. Additionally, STEMCstudio can consume external libraries without the need to spin up server-side resources. This allows applications to be launched with minimum time to become usable, and may in some cases improve scaling to large numbers of users or reduce cost. As with any flexible system, there is an attendant increase in complexity of understanding and/or effort of implementation. The goal of this section is to enable you to consume external libraries reliably and efficiently. The good news is that the process for consuming a package is systematic and therefore quite simple, if slightly laborious. The approach uses standard software engineering techniques and the result is reliable and performant.

Our approach for reaching the goal of consuming a library is as follows:

* Understand the general requirements for STEMCstudio interoperability.
* Know how to research the suitability of an external library.
* Be able to choose the correct implementation approach for a given library.
* Include the library as a dependency in a STEMCstudio project.

==== Library Requirements for Interoperability with STEMCstudio

STEMCstudio is open to use any external library provided that library meets some particular requirements. These requirements are mostly industry standards, but some are additional and specific to STEMCstudio yet consistent. When you author your own library, it takes little extra effort to ensure that the library works seamlessly and efficiently with STEMCstudio. However, with third party libraries and when these requirements are not met, it is always possible to create wrapper libraries that expose the required functionality suitable for consumption by STEMCstudio. The requirements pertain to the design-time and runtime usage of the library.

==== Designtime Requirements

STEMCstudio is able to offer editor support for an external library (package) when the TypeScript type definitions ('*.d.ts" files) for the package exist and are locatable. In the ideal case, the type definitions are maintained by the package authors in order to keep them synchronized with the implementation code, the definitions are co-located with the package on a CDN, and the 'package.json' file for the package provides the relative location of the type definitions. Increasingly, as package authors use TypeScript as their source language, the type definitions are built along with the source code to keep them automatically synchronized, and the location is described in the 'package.json' file. However, there are examples of some popular libraries where type definitions are independently and manually maintained in a separate package, and some cases where they do not exist at all. There are solutions for all these cases that fill in the missing pieces and allow STEMCstudio to use almost any package.

==== Runtime Requirements

STEMCstudio performs most efficiently when a library is in the 'system' module format. The 'system' module format is used by STEMCstudio because it allows module loading to be performed entirely in the browser. While the 'system' module format is an industry standard (and an output of the TypeScript compiler), popular libraries that directly implement this module format are rare. However, if a package does not implement the 'system' format you are not always required to roll up your engineering sleeves and implement a wrapper to perform the conversion. For eample, a common module format that can be consumed directly and almost as efficiently by STEMCstudio is the Universal Module Definition (UMD). The operation with UMD is acceptable because the conversion to 'system' format, which happens at runtime, is relatively efficient.  The UMD format, while common, is an unofficial legacy format. The industry is evolving towards use of the EcmaScript module format (ESM). The ESM format can also be transpiled at runtime to the 'system' format but at present this requires the use of the TypeScript transpiler and a hefty (approx 10MB) download. For this reason, it is preferable to convert ESM to system format by wrapping the original library. Whatever the case, there are solutions to make your favorite library available to STEMCstudio, and we will cover them in this document.

NOTE: Chapter 7 provides concrete help and best practices for authoring a JavaScript library optimized for STEMCstudio.

==== Researching a Package for use in STEMCstudio

The first step to incorporate an external library is finding out where it is deployed and how the various library artifacts are stored
in that deployment. We'll use the term Content Delivery Network (CDN) for a server that stores library artifacts and makes them available over the web using a URL.

The de-facto standard for making a JavaScript library available for widespread consumption is for the author to publish it to `npm`, the Node Package Manager. Don't be misled by the name, many packages are defined in npm even if there is no intention of using the library in Node.JS.

NOTE: There have been other package managers for JavaScript that are explicitly intended for the Browser rather than Node. e.g. Bower. However, these appear to have fallen out of favor and `npm` is the de-facto standard.

We'll assume that the library that you intend to use has been published to `npm` as a package, and that you know the package name. If the library has not been published to npm, you will need to contact the library author to get details about the library for consuming it. In this case your solution will likely include downloading the library and wrapping it in your own package that you publish to npm.

The information that we need about a library includes its name, available versions, available JavaScript module formats, the URL path to the bundled JavaScript implementation and the URL for the TypeScript definitions.

==== Inspecting a Package using online tools

There are two online websites that may be used to inspect an npm package. One is the 'npm' repository website itself, `https://www.npmjs.com`. Another is the popular 'jsdelivr' CDN, `https://www.jsdelivr.com` website. Both of these websites allow you to search for a package, inspect the available versions, and even browse the file structure and file contents of the available resources.

We'll use the 'npm' repository website here because it is the "source of truth", but you should also visit the jsdelivr website because you will need a CDN and the URLs for retrieving code are CDN specific.

NOTE: An alternative to the jsdelivr CDN is `https://unpkg.com`. This also contains packages that are published to 'npm'. However, I have found 'jsdelivr.com' to be more reliable than 'unpkg.com'. My understanding is that jsdelivr uses an extensive network of servers for production use whereas unpkg has far less hardware and is more suitable for prototyping. 

Navigating to `https://www.npmjs.com` in a web browser will bring you to the `npm` search page. Enter the desired package name, or other known descriptive details, to find the package. The author may have provided the information you require in human-readable text on the package home page. Another way you can find the information is to make use of the `package.json` file that accompanies every library that is published to npm. For example, if the GitHub repository where the source code is located is provided in `npm`, you can navigate to that repository and find the `package.json` file in the root of the project.

==== Modern and Legacy package.json properties.

With the advent of ESM, the specification for how the 'package.json' file should describe the location of file resources has become more sophisticated and slightly fragmented. One example of fragemtation is that there exists a "modern" specification based upon the 'exports' JSON property and a "legacy" specification that uses a number of JSON properties. Some packages will use both approaches and consider the "legacy" approach to be a fallback mechanism. Another fragmentation example is that runtime behavior is specified in the a `Node.JS` specification, but this specification makes no mention of how designtime support is provided. Finally, module formats beyond 'ESM' are not covered and so there are no guidelines for extension. The resolution of this fragmentation is that different interests have supplied their own specifications. Fortunately, the core `exports` specification is quite flexible and there is plenty of room for the different interests to coexist quite nicely. 

NOTE: This document will not attempt to reproduce the official specification, which is located here 'https://nodejs.org/api/packages.html#package-entry-points'. It should also be noted that the 'Node.JS' documentation does not define how type definitions are to be located. The specification for type definitions is not so well formalized. The TypeScript authors offer some guidelines at `https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html`, but this only appears to cover the "legacy" case. Some package authors have extrapolated to the "modern" case. The de-facto standard for type definitions is implemented in the appendices to this document. Additionally, the approach for location the 'system' module format is covered for when you author your own libraries or wrap a popular library.

==== Ideal package.json file for consumption by STEMCstudio

A concrete working example is probably in order. Consider the following fragment of a `package.json` file distributed with a package that was custom built to be used in STEMCstudio:

[source,json,linenos]
----
include::https://raw.githubusercontent.com/geometryzen/davinci-eight/master/package.json?cache_bust='{revdatetime}'[lines=5..13]
----

Take a look at the `exports` property first and the descendant property `default`. The corresponding value is "./dist/esm/index.js". The value is the location of the ESM module implementation relative to the `package.json` file. This is in accordance with the `Node.JS` specification.

NOTE: I won't fully explain the properties that can exist underneath the `exports` property, nor how they work. You should refer to the `Node.JS` documentation. For our purpose it is sufficient to know that the properties under `export` can describe paths that provide a means to filter the available resources and that the period in this case refers to the top-level module.

Now look at the `types` property that is a sibling to the `default` property and also under the `exports` property. The value of this property is "./dist/index.d.ts" and defines the relative location of the TypeScript type definitions. This `types` property is not part of the `Node.JS` specification and instead comes from the TypeScript documentation. The `types` property under `exports` is important to STEMCstudio because it enables design time editing support.

The remaining `system` sibling property is a STEMCstudio standard. It describes the entry point for the runtime in `system` module format.

Finally, the `module` and `types` properties that are sibling to `exports` are the "legacy" mechanism for location resources. STEMCstudio will not use these if it can find the `exports` property.

==== Consuming an Ideal package in STEMCstudio

==== When the third-party package is less than Ideal for STEMCstudio


TIP: A more reliable way to reverse-engineer the implementation artifacts is to create a dummy project and then install the npm package that you are interested in. Inspect the _node_modules_ folder to find your package and examine its structure. You may have to look inside the files themselves to determine their module format or suitability. 

So, we have reverse engineered the relative locations of various artifacts! But what about the base URL where the project is stored? The good news is that any package deployed to `npm` is automatically available on a CDN at `https://unpkg.com`, and the path to an artifact has the form `https://unpkg.com/package-name@version/path/to/artifact.ext`.

Let's see how these URLs are used in configuration files `system.config.json` and `types.config.json` STEMCstudio.

NOTE: If you don't see these files in the Explorer Files list then it could be that configuration files are being hidden. This behavior can be controlled through the Hide Configuration Files option in Project Settings.

STEMCstudio uses a file called `system.config.json` to define the mapping from a bare module reference to a JavaScript implementation:

[source,json,linenos]
----
include::https://gist.githubusercontent.com/stemcstudio/b78f5aeb32c1aca6c3d8382c9d57d9e8/raw/system.config.json?cache_bust='{revdatetime}'[]
----

STEMCstudio uses a file called `types.config.json` to define the mapping from a bare module reference to a TypeScript type definition file:

[source,json,linenos]
----
include::https://gist.githubusercontent.com/stemcstudio/b78f5aeb32c1aca6c3d8382c9d57d9e8/raw/types.config.json?cache_bust='{revdatetime}'[]
----

WARNING: Notice that the URL value in the `types.config.json` is an array of URL strings, whereas in the `system.config.json` it is a single URL string.

NOTE: Some points worth noting: STEMCstudio can consume the `system` format directly, but it is rare for library authors to distribute this format. The `umd` format is encountered frequently and can be consumed with a low overhead by being converted to the `system` format. The `esm` format can be consumed by STEMCstudio but this involves the small overhead of transpiling to the `system` format. 

==== Consuming EcmaScript Modules in STEMCstudio

STEMCstudio simulates the browser ES module loader by transpiling ESM code into the `System` format. In the Live Coding Editor it does this on-the-fly for TypeScript code in your project. STEMCstudio can also transpile external libraries. However, there is a catch. For external libraries in ESM format, the `System` loader needs to transpile the code before it can be executed. This in turn requires loading the `typescript.js` file as an ordinary script in your HTML file:

```
<script src='https://path/to/typescript.js'></script>
```

But `typescript.js` is a large (approx 10MB) file so this can be slow and can seriously affect the load time of your application. Using the `async` or `defer` attributes to control the load either does not help with performance or does not solve the problem. Additionally, transpiling the external module on-the-fly may not work if the the library is not bundled into a single file.

An alternative approach, described in the Appendix, is to convert ESM-only libraries into `System` format up-front. This is highly recommended for production applications. It can also solve the problem of bundling external module files.

For prototyping, it may be acceptable to convert the ESM module at execution time. To use an external library in the `esm` module format you will need to make TypeScript available to the `System` loader. To do this, add the following script tag near the bottom of the head tag in `index.html`.

```
<script src='https://stemcstudio.com/vendor/typescript@4.4.0/typescript.js'></script>
```
